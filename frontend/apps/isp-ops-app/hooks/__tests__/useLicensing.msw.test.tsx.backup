/**
 * MSW-based tests for useLicensing hooks
 * Tests licensing framework with realistic API mocking
 */

import { renderHook, waitFor, act } from "@testing-library/react";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import {
  useLicensing,
  useFeatureEntitlement,
  useQuotaCheck,
  licensingKeys,
} from "../useLicensing";
import {
  clearLicensingData,
  seedModules,
  seedQuotas,
  seedPlans,
  seedSubscription,
  seedQuotaUsage,
} from "@/__tests__/msw/handlers/licensing";
import { makeApiEndpointFail } from "@/__tests__/test-utils";

// Mock logger
jest.mock("@/lib/logger", () => ({
  logger: {
    info: jest.fn(),
    warn: jest.fn(),
    error: jest.fn(),
  },
}));

const createWrapper = () => {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: { retry: false },
      mutations: { retry: false },
    },
  });
  return ({ children }: { children: React.ReactNode }) => (
    <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
  );
};

describe("useLicensing", () => {
  beforeEach(() => {
    clearLicensingData();
  });

  describe("licensingKeys - Query Key Factory", () => {
    it("should generate correct query keys", () => {
      expect(licensingKeys.all).toEqual(["licensing"]);
      expect(licensingKeys.modules()).toEqual(["licensing", "modules"]);
      expect(licensingKeys.module("mod-1")).toEqual(["licensing", "module", "mod-1"]);
      expect(licensingKeys.quotas()).toEqual(["licensing", "quotas"]);
      expect(licensingKeys.plans()).toEqual(["licensing", "plans"]);
      expect(licensingKeys.plan("plan-1")).toEqual(["licensing", "plan", "plan-1"]);
      expect(licensingKeys.subscription()).toEqual(["licensing", "subscription"]);
      expect(licensingKeys.entitlement("MODULE_CODE", "CAPABILITY_CODE")).toEqual([
        "licensing",
        "entitlement",
        { moduleCode: "MODULE_CODE", capabilityCode: "CAPABILITY_CODE" },
      ]);
      expect(licensingKeys.quotaCheck("QUOTA_CODE", 5)).toEqual([
        "licensing",
        "quota-check",
        { quotaCode: "QUOTA_CODE", quantity: 5 },
      ]);
    });
  });

  describe("useLicensing - Feature Modules Query", () => {
    it("should fetch modules successfully", async () => {
      seedModules([
        {
          id: "mod-1",
          module_code: "BILLING",
          module_name: "Billing Module",
          description: "Billing features",
          category: "BILLING",
          pricing_model: "FLAT_FEE",
          base_price: 199.99,
          dependencies: [],
          config_schema: {},
          default_config: {},
          is_active: true,
          is_public: true,
          extra_metadata: {},
        },
      ]);

      const { result } = renderHook(() => useLicensing(), {
        wrapper: createWrapper(),
      });

      await waitFor(() => expect(result.current.modulesLoading).toBe(false));

      expect(result.current.modules).toHaveLength(1);
      expect(result.current.modules[0].module_code).toBe("BILLING");
      expect(result.current.modulesError).toBeNull();
    });

    it("should handle empty modules array", async () => {
      const { result } = renderHook(() => useLicensing(), {
        wrapper: createWrapper(),
      });

      await waitFor(() => expect(result.current.modulesLoading).toBe(false));

      expect(result.current.modules).toEqual([]);
      expect(result.current.modulesError).toBeNull();
    });

    it("should set loading state correctly for modules", async () => {
      const { result } = renderHook(() => useLicensing(), {
        wrapper: createWrapper(),
      });

      expect(result.current.modulesLoading).toBe(true);

      await waitFor(() => expect(result.current.modulesLoading).toBe(false));
    });
  });

  describe("useLicensing - Quotas Query", () => {
    it("should fetch quotas successfully", async () => {
      seedQuotas([
        {
          id: "quota-1",
          quota_code: "SUBSCRIBERS",
          quota_name: "Subscribers",
          description: "Number of subscribers",
          unit_name: "subscriber",
          unit_plural: "subscribers",
          pricing_model: "PER_UNIT",
          default_limit: 100,
          is_active: true,
          is_metered: true,
          reset_period: "MONTHLY",
          extra_metadata: {},
        },
      ]);

      const { result } = renderHook(() => useLicensing(), {
        wrapper: createWrapper(),
      });

      await waitFor(() => expect(result.current.quotasLoading).toBe(false));

      expect(result.current.quotas).toHaveLength(1);
      expect(result.current.quotas[0].quota_code).toBe("SUBSCRIBERS");
      expect(result.current.quotasError).toBeNull();
    });

    it("should handle empty quotas array", async () => {
      const { result } = renderHook(() => useLicensing(), {
        wrapper: createWrapper(),
      });

      await waitFor(() => expect(result.current.quotasLoading).toBe(false));

      expect(result.current.quotas).toEqual([]);
      expect(result.current.quotasError).toBeNull();
    });

    it("should set loading state correctly for quotas", async () => {
      const { result } = renderHook(() => useLicensing(), {
        wrapper: createWrapper(),
      });

      expect(result.current.quotasLoading).toBe(true);

      await waitFor(() => expect(result.current.quotasLoading).toBe(false));
    });
  });

  describe("useLicensing - Service Plans Query", () => {
    it("should fetch plans successfully", async () => {
      seedPlans([
        {
          id: "plan-1",
          plan_code: "ENTERPRISE",
          plan_name: "Enterprise Plan",
          description: "Full featured plan",
          base_price_monthly: 299.99,
          annual_discount_percent: 20,
          trial_days: 14,
          is_public: true,
          is_active: true,
          extra_metadata: {},
        },
      ]);

      const { result } = renderHook(() => useLicensing(), {
        wrapper: createWrapper(),
      });

      await waitFor(() => expect(result.current.plansLoading).toBe(false));

      expect(result.current.plans).toHaveLength(1);
      expect(result.current.plans[0].plan_code).toBe("ENTERPRISE");
      expect(result.current.plansError).toBeNull();
    });

    it("should handle empty plans array", async () => {
      const { result } = renderHook(() => useLicensing(), {
        wrapper: createWrapper(),
      });

      await waitFor(() => expect(result.current.plansLoading).toBe(false));

      expect(result.current.plans).toEqual([]);
      expect(result.current.plansError).toBeNull();
    });

    it("should set loading state correctly for plans", async () => {
      const { result } = renderHook(() => useLicensing(), {
        wrapper: createWrapper(),
      });

      expect(result.current.plansLoading).toBe(true);

      await waitFor(() => expect(result.current.plansLoading).toBe(false));
    });
  });

  describe("Error Handling", () => {
    it("should handle modules fetch error", async () => {
      makeApiEndpointFail('get', '/api/v1/licensing/modules', 'Server error', 500);

      const { result } = renderHook(() => useLicensing(), {
        wrapper: createWrapper(),
      });

      await waitFor(() => expect(result.current.modulesLoading).toBe(false));

      expect(result.current.modulesError).toBeTruthy();
      expect(result.current.modules).toEqual([]);
    });

    it("should handle quotas fetch error", async () => {
      makeApiEndpointFail('get', '/api/v1/licensing/quotas', 'Server error', 500);

      const { result } = renderHook(() => useLicensing(), {
        wrapper: createWrapper(),
      });

      await waitFor(() => expect(result.current.quotasLoading).toBe(false));

      expect(result.current.quotasError).toBeTruthy();
      expect(result.current.quotas).toEqual([]);
    });

    it("should handle plans fetch error", async () => {
      makeApiEndpointFail('get', '/api/v1/licensing/plans', 'Server error', 500);

      const { result } = renderHook(() => useLicensing(), {
        wrapper: createWrapper(),
      });

      await waitFor(() => expect(result.current.plansLoading).toBe(false));

      expect(result.current.plansError).toBeTruthy();
      expect(result.current.plans).toEqual([]);
    });

    it("should handle subscription fetch error (non-404)", async () => {
      makeApiEndpointFail('get', '/api/v1/licensing/subscriptions/current', 'Server error', 500);

      const { result } = renderHook(() => useLicensing(), {
        wrapper: createWrapper(),
      });

      await waitFor(() => expect(result.current.subscriptionLoading).toBe(false));

      expect(result.current.subscriptionError).toBeTruthy();
    });

    it("should handle create module error", async () => {
      makeApiEndpointFail('post', '/api/v1/licensing/modules', 'Validation error', 400);

      const { result } = renderHook(() => useLicensing(), {
        wrapper: createWrapper(),
      });

      await waitFor(() => expect(result.current.modulesLoading).toBe(false));

      await act(async () => {
        try {
          await result.current.createModule({
            module_code: "INVALID",
            module_name: "Invalid Module",
            description: "Test",
            category: "BILLING",
            pricing_model: "FLAT_FEE",
            base_price: -100, // Invalid price
          });
          fail("Should have thrown an error");
        } catch (error) {
          expect(error).toBeDefined();
        }
      });
    });

    it("should handle update module error", async () => {
      seedModules([
        {
          id: "mod-1",
          module_code: "BILLING",
          module_name: "Billing Module",
        },
      ]);

      makeApiEndpointFail('patch', '/api/v1/licensing/modules/mod-1', 'Not found', 404);

      const { result } = renderHook(() => useLicensing(), {
        wrapper: createWrapper(),
      });

      await waitFor(() => expect(result.current.modulesLoading).toBe(false));

      await act(async () => {
        try {
          await result.current.updateModule("mod-1", {
            module_name: "Updated Name",
          });
          fail("Should have thrown an error");
        } catch (error) {
          expect(error).toBeDefined();
        }
      });
    });

    it("should handle entitlement check error", async () => {
      makeApiEndpointFail('post', '/api/v1/licensing/entitlements/check', 'Server error', 500);

      const { result } = renderHook(
        () => useFeatureEntitlement("BILLING", "CREATE_INVOICE"),
        { wrapper: createWrapper() }
      );

      await waitFor(() => expect(result.current.isLoading).toBe(false));

      // Should return not entitled on error
      expect(result.current.data?.entitled).toBe(false);
    });

    it("should handle quota check error", async () => {
      makeApiEndpointFail('post', '/api/v1/licensing/quotas/check', 'Server error', 500);

      const { result } = renderHook(() => useQuotaCheck("SUBSCRIBERS", 10), {
        wrapper: createWrapper(),
      });

      await waitFor(() => expect(result.current.isLoading).toBe(false));

      // Should return not available on error
      expect(result.current.data?.available).toBe(false);
      expect(result.current.data?.remaining).toBe(0);
    });
  });

  describe("useLicensing - Current Subscription Query", () => {
    it("should fetch current subscription successfully", async () => {
      seedSubscription({
        id: "sub-1",
        tenant_id: "tenant-1",
        plan_id: "plan-1",
        status: "ACTIVE",
        billing_cycle: "MONTHLY",
        monthly_price: 299.99,
        annual_price: 2999.99,
        current_period_start: "2024-01-01T00:00:00Z",
        current_period_end: "2024-02-01T00:00:00Z",
      });

      const { result } = renderHook(() => useLicensing(), {
        wrapper: createWrapper(),
      });

      await waitFor(() => expect(result.current.subscriptionLoading).toBe(false));

      expect(result.current.currentSubscription).toBeDefined();
      expect(result.current.currentSubscription?.id).toBe("sub-1");
      expect(result.current.subscriptionError).toBeNull();
    });

    it("should handle 404 for no subscription", async () => {
      // Don't seed any subscription
      const { result } = renderHook(() => useLicensing(), {
        wrapper: createWrapper(),
      });

      await waitFor(() => expect(result.current.subscriptionLoading).toBe(false));

      expect(result.current.currentSubscription).toBeUndefined();
      expect(result.current.subscriptionError).toBeNull();
    });
  });

  describe("useLicensing - Module Mutations", () => {
    it("should create module successfully", async () => {
      const { result } = renderHook(() => useLicensing(), {
        wrapper: createWrapper(),
      });

      await waitFor(() => expect(result.current.modulesLoading).toBe(false));

      let createdModule;
      await act(async () => {
        createdModule = await result.current.createModule({
          module_code: "ANALYTICS",
          module_name: "Analytics Module",
          description: "Analytics features",
          category: "ANALYTICS",
          pricing_model: "FLAT_FEE",
          base_price: 149.99,
        });
      });

      expect(createdModule).toBeDefined();
      expect(createdModule.module_code).toBe("ANALYTICS");
    });

    it("should update module successfully", async () => {
      seedModules([
        {
          id: "mod-1",
          module_code: "BILLING",
          module_name: "Billing Module",
          description: "Billing features",
          category: "BILLING",
          pricing_model: "FLAT_FEE",
          base_price: 199.99,
        },
      ]);

      const { result } = renderHook(() => useLicensing(), {
        wrapper: createWrapper(),
      });

      await waitFor(() => expect(result.current.modulesLoading).toBe(false));

      let updatedModule;
      await act(async () => {
        updatedModule = await result.current.updateModule("mod-1", {
          module_name: "Updated Billing Module",
        });
      });

      expect(updatedModule).toBeDefined();
      expect(updatedModule.module_name).toBe("Updated Billing Module");
    });
  });

  describe("useLicensing - Quota Mutations", () => {
    it("should create quota successfully", async () => {
      const { result } = renderHook(() => useLicensing(), {
        wrapper: createWrapper(),
      });

      await waitFor(() => expect(result.current.quotasLoading).toBe(false));

      let createdQuota;
      await act(async () => {
        createdQuota = await result.current.createQuota({
          quota_code: "API_CALLS",
          quota_name: "API Calls",
          description: "Number of API calls per month",
          unit_name: "call",
          unit_plural: "calls",
          pricing_model: "PER_UNIT",
          default_limit: 10000,
        });
      });

      expect(createdQuota).toBeDefined();
      expect(createdQuota.quota_code).toBe("API_CALLS");
    });

    it("should update quota successfully", async () => {
      seedQuotas([
        {
          id: "quota-1",
          quota_code: "SUBSCRIBERS",
          quota_name: "Subscribers",
          unit_name: "subscriber",
          unit_plural: "subscribers",
          default_limit: 100,
        },
      ]);

      const { result } = renderHook(() => useLicensing(), {
        wrapper: createWrapper(),
      });

      await waitFor(() => expect(result.current.quotasLoading).toBe(false));

      let updatedQuota;
      await act(async () => {
        updatedQuota = await result.current.updateQuota("quota-1", {
          quota_name: "Updated Subscribers",
          default_limit: 200,
        });
      });

      expect(updatedQuota).toBeDefined();
      expect(updatedQuota.quota_name).toBe("Updated Subscribers");
      expect(updatedQuota.default_limit).toBe(200);
    });
  });

  describe("useLicensing - Plan Mutations", () => {
    it("should create plan successfully", async () => {
      const { result } = renderHook(() => useLicensing(), {
        wrapper: createWrapper(),
      });

      await waitFor(() => expect(result.current.plansLoading).toBe(false));

      let createdPlan;
      await act(async () => {
        createdPlan = await result.current.createPlan({
          plan_code: "STARTER",
          plan_name: "Starter Plan",
          description: "Basic plan",
          base_price_monthly: 49.99,
          annual_discount_percent: 0,
          modules: [],
          quotas: [],
        });
      });

      expect(createdPlan).toBeDefined();
      expect(createdPlan.plan_code).toBe("STARTER");
    });

    it("should update plan successfully", async () => {
      seedPlans([
        {
          id: "plan-1",
          plan_code: "ENTERPRISE",
          plan_name: "Enterprise Plan",
          base_price_monthly: 299.99,
          annual_discount_percent: 10,
        },
      ]);

      const { result } = renderHook(() => useLicensing(), {
        wrapper: createWrapper(),
      });

      await waitFor(() => expect(result.current.plansLoading).toBe(false));

      let updatedPlan;
      await act(async () => {
        updatedPlan = await result.current.updatePlan("plan-1", {
          plan_name: "Updated Plan",
          base_price_monthly: 349.99,
        });
      });

      expect(updatedPlan).toBeDefined();
      expect(updatedPlan.plan_name).toBe("Updated Plan");
      expect(updatedPlan.base_price_monthly).toBe(349.99);
    });

    it("should duplicate plan successfully", async () => {
      seedPlans([
        {
          id: "plan-1",
          plan_code: "ENTERPRISE",
          plan_name: "Enterprise Plan",
          base_price_monthly: 299.99,
        },
      ]);

      const { result } = renderHook(() => useLicensing(), {
        wrapper: createWrapper(),
      });

      await waitFor(() => expect(result.current.plansLoading).toBe(false));

      let duplicatedPlan;
      await act(async () => {
        duplicatedPlan = await result.current.duplicatePlan("plan-1");
      });

      expect(duplicatedPlan).toBeDefined();
      expect(duplicatedPlan.plan_code).toBe("ENTERPRISE_COPY");
      expect(duplicatedPlan.plan_name).toBe("Enterprise Plan (Copy)");
    });
  });

  describe("useLicensing - Subscription Mutations", () => {
    it("should create subscription successfully", async () => {
      const { result } = renderHook(() => useLicensing(), {
        wrapper: createWrapper(),
      });

      await waitFor(() => expect(result.current.subscriptionLoading).toBe(false));

      let createdSubscription;
      await act(async () => {
        createdSubscription = await result.current.createSubscription({
          tenant_id: "tenant-1",
          plan_id: "plan-1",
          billing_cycle: "MONTHLY",
        });
      });

      expect(createdSubscription).toBeDefined();
      expect(createdSubscription.tenant_id).toBe("tenant-1");
      expect(createdSubscription.status).toBe("ACTIVE");
    });

    it("should add addon successfully", async () => {
      seedSubscription({
        id: "sub-1",
        tenant_id: "tenant-1",
        plan_id: "plan-1",
        status: "ACTIVE",
        billing_cycle: "MONTHLY",
        addons: [],
      });

      const { result } = renderHook(() => useLicensing(), {
        wrapper: createWrapper(),
      });

      await waitFor(() => expect(result.current.subscriptionLoading).toBe(false));

      expect(result.current.currentSubscription?.addons).toEqual([]);

      await act(async () => {
        await result.current.addAddon({
          module_id: "addon-1",
          quantity: 1,
        });
      });

      // Wait for cache invalidation and refetch
      await waitFor(() => {
        expect(result.current.currentSubscription?.addons).toContainEqual(
          expect.objectContaining({ module_id: "addon-1" })
        );
      });
    });

    it("should remove addon successfully", async () => {
      seedSubscription({
        id: "sub-1",
        tenant_id: "tenant-1",
        plan_id: "plan-1",
        status: "ACTIVE",
        billing_cycle: "MONTHLY",
        addons: [{ module_id: "addon-1", quantity: 1 }],
      });

      const { result } = renderHook(() => useLicensing(), {
        wrapper: createWrapper(),
      });

      await waitFor(() => expect(result.current.subscriptionLoading).toBe(false));

      expect(result.current.currentSubscription?.addons).toHaveLength(1);

      await act(async () => {
        await result.current.removeAddon({
          module_id: "addon-1",
        });
      });

      // Wait for cache invalidation and refetch
      await waitFor(() => {
        expect(result.current.currentSubscription?.addons).toEqual([]);
      });
    });
  });

  describe("useLicensing - Helper Functions", () => {
    it("should get module by id", async () => {
      seedModules([
        {
          id: "mod-1",
          module_code: "BILLING",
          module_name: "Billing Module",
        },
      ]);

      const { result } = renderHook(() => useLicensing(), {
        wrapper: createWrapper(),
      });

      await waitFor(() => expect(result.current.modulesLoading).toBe(false));

      let fetchedModule;
      await act(async () => {
        fetchedModule = await result.current.getModule("mod-1");
      });

      expect(fetchedModule).toBeDefined();
      expect(fetchedModule.id).toBe("mod-1");
      expect(fetchedModule.module_code).toBe("BILLING");
    });

    it("should get plan by id", async () => {
      seedPlans([
        {
          id: "plan-1",
          plan_code: "ENTERPRISE",
          plan_name: "Enterprise Plan",
        },
      ]);

      const { result } = renderHook(() => useLicensing(), {
        wrapper: createWrapper(),
      });

      await waitFor(() => expect(result.current.plansLoading).toBe(false));

      let fetchedPlan;
      await act(async () => {
        fetchedPlan = await result.current.getPlan("plan-1");
      });

      expect(fetchedPlan).toBeDefined();
      expect(fetchedPlan.id).toBe("plan-1");
      expect(fetchedPlan.plan_code).toBe("ENTERPRISE");
    });

    it("should calculate plan price", async () => {
      seedPlans([
        {
          id: "plan-1",
          plan_code: "ENTERPRISE",
          plan_name: "Enterprise Plan",
          base_price_monthly: 299.99,
          annual_discount_percent: 10,
        },
      ]);

      const { result } = renderHook(() => useLicensing(), {
        wrapper: createWrapper(),
      });

      await waitFor(() => expect(result.current.plansLoading).toBe(false));

      let pricing;
      await act(async () => {
        pricing = await result.current.calculatePlanPrice("plan-1", {
          billing_period: "ANNUAL",
          quantity: 1,
        });
      });

      expect(pricing).toBeDefined();
      expect(pricing.billing_period).toBe("ANNUAL");
      expect(pricing.total).toBeDefined();
      expect(pricing.currency).toBe("USD");
    });

    it("should check entitlement", async () => {
      seedSubscription({
        id: "sub-1",
        tenant_id: "tenant-1",
        plan_id: "plan-1",
        status: "ACTIVE",
        billing_cycle: "MONTHLY",
      });

      const { result } = renderHook(() => useLicensing(), {
        wrapper: createWrapper(),
      });

      await waitFor(() => expect(result.current.modulesLoading).toBe(false));

      let response;
      await act(async () => {
        response = await result.current.checkEntitlement({
          module_code: "BILLING",
          capability_code: "CREATE_INVOICE",
        });
      });

      expect(response).toBeDefined();
      expect(response.entitled).toBe(true);
    });

    it("should check quota", async () => {
      seedQuotas([
        {
          id: "quota-1",
          quota_code: "SUBSCRIBERS",
          quota_name: "Subscribers",
          unit_name: "subscriber",
          unit_plural: "subscribers",
          default_limit: 100,
        },
      ]);
      seedQuotaUsage("SUBSCRIBERS", 50);

      const { result } = renderHook(() => useLicensing(), {
        wrapper: createWrapper(),
      });

      await waitFor(() => expect(result.current.quotasLoading).toBe(false));

      let response;
      await act(async () => {
        response = await result.current.checkQuota({
          quota_code: "SUBSCRIBERS",
          quantity: 10,
        });
      });

      expect(response).toBeDefined();
      expect(response.available).toBe(true);
      expect(response.remaining).toBe(50);
      expect(response.used).toBe(50);
    });

    it("should consume quota", async () => {
      seedQuotas([
        {
          id: "quota-1",
          quota_code: "API_CALLS",
          quota_name: "API Calls",
          default_limit: 10000,
          unit_name: "call",
          unit_plural: "calls",
        },
      ]);
      seedQuotaUsage("API_CALLS", 0);

      const { result } = renderHook(() => useLicensing(), {
        wrapper: createWrapper(),
      });

      await waitFor(() => expect(result.current.quotasLoading).toBe(false));

      let consumeResult;
      await act(async () => {
        consumeResult = await result.current.consumeQuota({
          quota_code: "API_CALLS",
          quantity: 100,
        });
      });

      // Verify consumption succeeded - check quota usage increased
      const checkResult = await result.current.checkQuota({
        quota_code: "API_CALLS",
        quantity: 1,
      });

      expect(checkResult.used).toBe(100);
    });

    it("should release quota", async () => {
      seedQuotas([
        {
          id: "quota-1",
          quota_code: "SUBSCRIBERS",
          quota_name: "Subscribers",
          default_limit: 100,
          unit_name: "subscriber",
          unit_plural: "subscribers",
        },
      ]);
      seedQuotaUsage("SUBSCRIBERS", 50);

      const { result } = renderHook(() => useLicensing(), {
        wrapper: createWrapper(),
      });

      await waitFor(() => expect(result.current.quotasLoading).toBe(false));

      const beforeCheck = await result.current.checkQuota({
        quota_code: "SUBSCRIBERS",
        quantity: 1,
      });
      expect(beforeCheck.used).toBe(50);

      await act(async () => {
        await result.current.releaseQuota({
          quota_code: "SUBSCRIBERS",
          quantity: 5,
        });
      });

      // Verify quota was released - usage should decrease
      const afterCheck = await result.current.checkQuota({
        quota_code: "SUBSCRIBERS",
        quantity: 1,
      });
      expect(afterCheck.used).toBe(45);
    });

    it("should refetch all licensing data", async () => {
      const { result } = renderHook(() => useLicensing(), {
        wrapper: createWrapper(),
      });

      await waitFor(() => expect(result.current.modulesLoading).toBe(false));

      await act(async () => {
        await result.current.refetch();
      });

      // Refetch completes without error
      expect(result.current.modules).toBeDefined();
    });
  });

  describe("useFeatureEntitlement", () => {
    it("should check entitlement successfully", async () => {
      seedSubscription({
        id: "sub-1",
        tenant_id: "tenant-1",
        plan_id: "plan-1",
        status: "ACTIVE",
        billing_cycle: "MONTHLY",
      });

      const { result } = renderHook(
        () => useFeatureEntitlement("BILLING", "CREATE_INVOICE"),
        {
          wrapper: createWrapper(),
        }
      );

      await waitFor(() => expect(result.current.isLoading).toBe(false));

      expect(result.current.data?.entitled).toBe(true);
    });

    it("should return not entitled when no module code", async () => {
      const { result } = renderHook(() => useFeatureEntitlement(), {
        wrapper: createWrapper(),
      });

      await waitFor(() => expect(result.current.isLoading).toBe(false));

      expect(result.current.data).toBeUndefined();
    });

    it("should not fetch when module code is undefined", async () => {
      const { result } = renderHook(() => useFeatureEntitlement(undefined), {
        wrapper: createWrapper(),
      });

      await waitFor(() => expect(result.current.isLoading).toBe(false));

      expect(result.current.data).toBeUndefined();
    });

    it("should handle disabled module", async () => {
      seedSubscription({
        id: "sub-1",
        tenant_id: "tenant-1",
        plan_id: "plan-1",
        status: "ACTIVE",
        billing_cycle: "MONTHLY",
      });

      const { result } = renderHook(() => useFeatureEntitlement("DISABLED_MODULE"), {
        wrapper: createWrapper(),
      });

      await waitFor(() => expect(result.current.isLoading).toBe(false));

      expect(result.current.data?.entitled).toBe(false);
    });
  });

  describe("useQuotaCheck", () => {
    it("should check quota successfully", async () => {
      seedQuotas([
        {
          id: "quota-1",
          quota_code: "SUBSCRIBERS",
          quota_name: "Subscribers",
          default_limit: 100,
        },
      ]);
      seedQuotaUsage("SUBSCRIBERS", 50);

      const { result } = renderHook(() => useQuotaCheck("SUBSCRIBERS", 10), {
        wrapper: createWrapper(),
      });

      await waitFor(() => expect(result.current.isLoading).toBe(false));

      expect(result.current.data?.available).toBe(true);
      expect(result.current.data?.remaining).toBe(50);
      expect(result.current.data?.details).toBeDefined();
    });

    it("should use default quantity of 1", async () => {
      seedQuotas([
        {
          id: "quota-1",
          quota_code: "SUBSCRIBERS",
          quota_name: "Subscribers",
          default_limit: 100,
        },
      ]);
      seedQuotaUsage("SUBSCRIBERS", 50);

      const { result } = renderHook(() => useQuotaCheck("SUBSCRIBERS"), {
        wrapper: createWrapper(),
      });

      await waitFor(() => expect(result.current.isLoading).toBe(false));

      expect(result.current.data?.available).toBe(true);
    });

    it("should handle insufficient quota", async () => {
      seedQuotas([
        {
          id: "quota-1",
          quota_code: "SUBSCRIBERS",
          quota_name: "Subscribers",
          default_limit: 100,
        },
      ]);
      seedQuotaUsage("SUBSCRIBERS", 95);

      const { result } = renderHook(() => useQuotaCheck("SUBSCRIBERS", 10), {
        wrapper: createWrapper(),
      });

      await waitFor(() => expect(result.current.isLoading).toBe(false));

      expect(result.current.data?.available).toBe(false);
      expect(result.current.data?.remaining).toBe(5);
    });
  });

  describe("Cache Invalidation", () => {
    it("should invalidate modules cache after creating module", async () => {
      const { result } = renderHook(() => useLicensing(), {
        wrapper: createWrapper(),
      });

      await waitFor(() => expect(result.current.modulesLoading).toBe(false));

      expect(result.current.modules).toHaveLength(0);

      await act(async () => {
        await result.current.createModule({
          module_code: "NEW_MOD",
          module_name: "New Module",
          description: "Test",
          category: "AUTOMATION",
          pricing_model: "FLAT_FEE",
          base_price: 49.99,
        });
      });

      // Wait for cache invalidation and refetch
      await waitFor(() => {
        expect(result.current.modules.length).toBeGreaterThan(0);
      });
    });

    it("should invalidate subscription cache after adding addon", async () => {
      seedSubscription({
        id: "sub-1",
        tenant_id: "tenant-1",
        plan_id: "plan-1",
        status: "ACTIVE",
        billing_cycle: "MONTHLY",
        addons: [],
      });

      const { result } = renderHook(() => useLicensing(), {
        wrapper: createWrapper(),
      });

      await waitFor(() => expect(result.current.subscriptionLoading).toBe(false));

      expect(result.current.currentSubscription).toBeDefined();

      await act(async () => {
        await result.current.addAddon({ module_id: "mod-addon" });
      });

      // Cache invalidation triggers refetch
      await waitFor(() => {
        expect(result.current.currentSubscription).toBeDefined();
      });
    });

    it("should invalidate quotas cache after creating quota", async () => {
      const queryClient = new QueryClient({
        defaultOptions: { queries: { retry: false }, mutations: { retry: false } },
      });

      const wrapper = ({ children }: { children: React.ReactNode }) => (
        <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
      );

      const { result } = renderHook(() => useLicensing(), { wrapper });

      await waitFor(() => expect(result.current.quotasLoading).toBe(false));

      expect(result.current.quotas).toHaveLength(0);

      await act(async () => {
        await result.current.createQuota({
          quota_code: "NEW_QUOTA",
          quota_name: "New Quota",
          description: "Test quota",
          unit_name: "unit",
          unit_plural: "units",
          pricing_model: "PER_UNIT",
          default_limit: 100,
        });
      });

      // Wait for cache invalidation and refetch
      await waitFor(() => {
        const queryState = queryClient.getQueryState(licensingKeys.quotas());
        expect(queryState?.isInvalidated || result.current.quotas.length > 0).toBe(true);
      });
    });

    it("should invalidate plans cache after creating plan", async () => {
      const queryClient = new QueryClient({
        defaultOptions: { queries: { retry: false }, mutations: { retry: false } },
      });

      const wrapper = ({ children }: { children: React.ReactNode }) => (
        <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
      );

      const { result } = renderHook(() => useLicensing(), { wrapper });

      await waitFor(() => expect(result.current.plansLoading).toBe(false));

      expect(result.current.plans).toHaveLength(0);

      await act(async () => {
        await result.current.createPlan({
          plan_code: "NEW_PLAN",
          plan_name: "New Plan",
          description: "Test plan",
          base_price_monthly: 99.99,
          annual_discount_percent: 10,
          modules: [],
          quotas: [],
        });
      });

      // Wait for cache invalidation and refetch
      await waitFor(() => {
        expect(result.current.plans.length).toBeGreaterThan(0);
      });
    });

    it("should invalidate modules cache after updating module", async () => {
      seedModules([
        {
          id: "mod-1",
          module_code: "BILLING",
          module_name: "Billing Module",
        },
      ]);

      const queryClient = new QueryClient({
        defaultOptions: { queries: { retry: false }, mutations: { retry: false } },
      });

      const wrapper = ({ children }: { children: React.ReactNode }) => (
        <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
      );

      const { result } = renderHook(() => useLicensing(), { wrapper });

      await waitFor(() => expect(result.current.modulesLoading).toBe(false));

      const originalName = result.current.modules[0].module_name;

      await act(async () => {
        await result.current.updateModule("mod-1", {
          module_name: "Updated Billing Module",
        });
      });

      // Wait for cache invalidation and refetch
      await waitFor(() => {
        expect(result.current.modules[0].module_name).not.toBe(originalName);
      });
    });

    it("should invalidate quotas cache after updating quota", async () => {
      seedQuotas([
        {
          id: "quota-1",
          quota_code: "SUBSCRIBERS",
          quota_name: "Subscribers",
          default_limit: 100,
        },
      ]);

      const queryClient = new QueryClient({
        defaultOptions: { queries: { retry: false }, mutations: { retry: false } },
      });

      const wrapper = ({ children }: { children: React.ReactNode }) => (
        <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
      );

      const { result } = renderHook(() => useLicensing(), { wrapper });

      await waitFor(() => expect(result.current.quotasLoading).toBe(false));

      await act(async () => {
        await result.current.updateQuota("quota-1", {
          default_limit: 200,
        });
      });

      // Wait for cache invalidation and refetch
      await waitFor(() => {
        expect(result.current.quotas[0].default_limit).toBe(200);
      });
    });

    it("should invalidate plans cache after updating plan", async () => {
      seedPlans([
        {
          id: "plan-1",
          plan_code: "ENTERPRISE",
          plan_name: "Enterprise Plan",
          base_price_monthly: 299.99,
        },
      ]);

      const queryClient = new QueryClient({
        defaultOptions: { queries: { retry: false }, mutations: { retry: false } },
      });

      const wrapper = ({ children }: { children: React.ReactNode }) => (
        <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
      );

      const { result } = renderHook(() => useLicensing(), { wrapper });

      await waitFor(() => expect(result.current.plansLoading).toBe(false));

      await act(async () => {
        await result.current.updatePlan("plan-1", {
          base_price_monthly: 349.99,
        });
      });

      // Wait for cache invalidation and refetch
      await waitFor(() => {
        expect(result.current.plans[0].base_price_monthly).toBe(349.99);
      });
    });
  });

  describe("Edge Cases", () => {
    it("should handle quota at exactly the limit", async () => {
      seedQuotas([
        {
          id: "quota-1",
          quota_code: "SUBSCRIBERS",
          quota_name: "Subscribers",
          default_limit: 100,
        },
      ]);
      seedQuotaUsage("SUBSCRIBERS", 100);

      const { result } = renderHook(() => useQuotaCheck("SUBSCRIBERS", 1), {
        wrapper: createWrapper(),
      });

      await waitFor(() => expect(result.current.isLoading).toBe(false));

      expect(result.current.data?.available).toBe(false);
      expect(result.current.data?.remaining).toBe(0);
    });

    it("should handle subscription with EXPIRED status", async () => {
      seedSubscription({
        id: "sub-1",
        tenant_id: "tenant-1",
        plan_id: "plan-1",
        status: "EXPIRED",
        billing_cycle: "MONTHLY",
      });

      const { result } = renderHook(() => useLicensing(), {
        wrapper: createWrapper(),
      });

      await waitFor(() => expect(result.current.subscriptionLoading).toBe(false));

      expect(result.current.currentSubscription?.status).toBe("EXPIRED");
    });

    it("should handle subscription with SUSPENDED status", async () => {
      seedSubscription({
        id: "sub-1",
        tenant_id: "tenant-1",
        plan_id: "plan-1",
        status: "SUSPENDED",
        billing_cycle: "MONTHLY",
      });

      const { result } = renderHook(() => useLicensing(), {
        wrapper: createWrapper(),
      });

      await waitFor(() => expect(result.current.subscriptionLoading).toBe(false));

      expect(result.current.currentSubscription?.status).toBe("SUSPENDED");
    });

    it("should handle zero default_limit quota", async () => {
      seedQuotas([
        {
          id: "quota-1",
          quota_code: "FREE_TIER",
          quota_name: "Free Tier",
          default_limit: 0,
        },
      ]);

      const { result } = renderHook(() => useLicensing(), {
        wrapper: createWrapper(),
      });

      await waitFor(() => expect(result.current.quotasLoading).toBe(false));

      expect(result.current.quotas[0].default_limit).toBe(0);
    });

    it("should handle plan with zero annual discount", async () => {
      seedPlans([
        {
          id: "plan-1",
          plan_code: "BASIC",
          plan_name: "Basic Plan",
          base_price_monthly: 9.99,
          annual_discount_percent: 0,
        },
      ]);

      const { result } = renderHook(() => useLicensing(), {
        wrapper: createWrapper(),
      });

      await waitFor(() => expect(result.current.plansLoading).toBe(false));

      expect(result.current.plans[0].annual_discount_percent).toBe(0);
    });

    it("should handle very large quota usage", async () => {
      seedQuotas([
        {
          id: "quota-1",
          quota_code: "API_CALLS",
          quota_name: "API Calls",
          default_limit: 1000000,
        },
      ]);
      seedQuotaUsage("API_CALLS", 999999);

      const { result } = renderHook(() => useQuotaCheck("API_CALLS", 1), {
        wrapper: createWrapper(),
      });

      await waitFor(() => expect(result.current.isLoading).toBe(false));

      expect(result.current.data?.available).toBe(true);
      expect(result.current.data?.remaining).toBe(1);
    });

    it("should handle quota with null/undefined reset_period", async () => {
      seedQuotas([
        {
          id: "quota-1",
          quota_code: "UNLIMITED",
          quota_name: "Unlimited Feature",
          default_limit: -1, // Unlimited
          reset_period: null,
        },
      ]);

      const { result } = renderHook(() => useLicensing(), {
        wrapper: createWrapper(),
      });

      await waitFor(() => expect(result.current.quotasLoading).toBe(false));

      expect(result.current.quotas[0].reset_period).toBeNull();
    });

    it("should handle module with empty dependencies array", async () => {
      seedModules([
        {
          id: "mod-1",
          module_code: "STANDALONE",
          module_name: "Standalone Module",
          dependencies: [],
        },
      ]);

      const { result } = renderHook(() => useLicensing(), {
        wrapper: createWrapper(),
      });

      await waitFor(() => expect(result.current.modulesLoading).toBe(false));

      expect(result.current.modules[0].dependencies).toEqual([]);
    });

    it("should handle plan with empty modules and quotas", async () => {
      seedPlans([
        {
          id: "plan-1",
          plan_code: "MINIMAL",
          plan_name: "Minimal Plan",
          base_price_monthly: 0,
          modules: [],
          quotas: [],
        },
      ]);

      const { result } = renderHook(() => useLicensing(), {
        wrapper: createWrapper(),
      });

      await waitFor(() => expect(result.current.plansLoading).toBe(false));

      expect(result.current.plans[0].modules).toEqual([]);
      expect(result.current.plans[0].quotas).toEqual([]);
    });
  });

  describe("Loading States", () => {
    it("should show correct loading state during queries", async () => {
      const { result } = renderHook(() => useLicensing(), {
        wrapper: createWrapper(),
      });

      expect(result.current.modulesLoading).toBe(true);
      expect(result.current.quotasLoading).toBe(true);
      expect(result.current.plansLoading).toBe(true);
      expect(result.current.subscriptionLoading).toBe(true);

      await waitFor(
        () => {
          expect(result.current.modulesLoading).toBe(false);
          expect(result.current.quotasLoading).toBe(false);
          expect(result.current.plansLoading).toBe(false);
          expect(result.current.subscriptionLoading).toBe(false);
        },
        { timeout: 500 }
      );
    });
  });

  describe("Stale Time and Refetch Behavior", () => {
    it("should mark modules query as fresh immediately after fetch", async () => {
      const queryClient = new QueryClient({
        defaultOptions: { queries: { retry: false }, mutations: { retry: false } },
      });

      const wrapper = ({ children }: { children: React.ReactNode }) => (
        <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
      );

      const { result } = renderHook(() => useLicensing(), { wrapper });

      await waitFor(() => expect(result.current.modulesLoading).toBe(false));

      // Check the query state
      const queryState = queryClient.getQueryState(licensingKeys.modules());
      expect(queryState?.dataUpdatedAt).toBeDefined();

      // Data should be fresh (not stale) immediately after fetch
      expect(queryState?.isStale).toBe(false);
    });

    it("should mark subscription query as fresh immediately after fetch", async () => {
      seedSubscription({
        id: "sub-1",
        tenant_id: "tenant-1",
        plan_id: "plan-1",
        status: "ACTIVE",
        billing_cycle: "MONTHLY",
      });

      const queryClient = new QueryClient({
        defaultOptions: { queries: { retry: false }, mutations: { retry: false } },
      });

      const wrapper = ({ children }: { children: React.ReactNode }) => (
        <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
      );

      const { result } = renderHook(() => useLicensing(), { wrapper });

      await waitFor(() => expect(result.current.subscriptionLoading).toBe(false));

      const queryState = queryClient.getQueryState(licensingKeys.subscription());
      expect(queryState?.dataUpdatedAt).toBeDefined();
      expect(queryState?.isStale).toBe(false);
    });

    it("should refetch on window focus when enabled", async () => {
      seedModules([
        {
          id: "mod-1",
          module_code: "BILLING",
          module_name: "Billing Module",
        },
      ]);

      const queryClient = new QueryClient({
        defaultOptions: { queries: { retry: false }, mutations: { retry: false } },
      });

      const wrapper = ({ children }: { children: React.ReactNode }) => (
        <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
      );

      const { result } = renderHook(() => useLicensing(), { wrapper });

      await waitFor(() => expect(result.current.modulesLoading).toBe(false));

      expect(result.current.modules).toHaveLength(1);

      // Verify refetchOnWindowFocus is enabled
      const queryOptions = queryClient.getQueryCache().find(licensingKeys.modules())?.options;
      expect(queryOptions?.refetchOnWindowFocus).toBe(true);
    });
  });

  describe("Query Deduplication", () => {
    it("should deduplicate concurrent module queries", async () => {
      seedModules([
        {
          id: "mod-1",
          module_code: "BILLING",
          module_name: "Billing Module",
        },
      ]);

      const queryClient = new QueryClient({
        defaultOptions: { queries: { retry: false }, mutations: { retry: false } },
      });

      const wrapper = ({ children }: { children: React.ReactNode }) => (
        <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
      );

      // Render two hooks concurrently
      const { result: result1 } = renderHook(() => useLicensing(), { wrapper });
      const { result: result2 } = renderHook(() => useLicensing(), { wrapper });

      await waitFor(() => {
        expect(result1.current.modulesLoading).toBe(false);
        expect(result2.current.modulesLoading).toBe(false);
      });

      // Both hooks should have the same data
      expect(result1.current.modules).toEqual(result2.current.modules);
      expect(result1.current.modules).toHaveLength(1);
      expect(result2.current.modules).toHaveLength(1);
    });

    it("should share query results across multiple hooks", async () => {
      seedQuotas([
        {
          id: "quota-1",
          quota_code: "SUBSCRIBERS",
          quota_name: "Subscribers",
          default_limit: 100,
        },
      ]);

      const queryClient = new QueryClient({
        defaultOptions: { queries: { retry: false }, mutations: { retry: false } },
      });

      const wrapper = ({ children }: { children: React.ReactNode }) => (
        <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
      );

      const { result: result1 } = renderHook(() => useLicensing(), { wrapper });

      await waitFor(() => expect(result1.current.quotasLoading).toBe(false));

      // Create second hook after first one loads
      const { result: result2 } = renderHook(() => useLicensing(), { wrapper });

      await waitFor(() => expect(result2.current.quotasLoading).toBe(false));

      // Second hook should get cached data immediately
      expect(result2.current.quotas).toEqual(result1.current.quotas);
    });

    it("should not refetch when data is fresh", async () => {
      seedPlans([
        {
          id: "plan-1",
          plan_code: "ENTERPRISE",
          plan_name: "Enterprise Plan",
        },
      ]);

      const queryClient = new QueryClient({
        defaultOptions: { queries: { retry: false }, mutations: { retry: false } },
      });

      const wrapper = ({ children }: { children: React.ReactNode }) => (
        <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
      );

      const { result: result1 } = renderHook(() => useLicensing(), { wrapper });

      await waitFor(() => expect(result1.current.plansLoading).toBe(false));

      const firstDataTimestamp = queryClient.getQueryState(licensingKeys.plans())?.dataUpdatedAt;

      // Render another hook immediately after
      const { result: result2 } = renderHook(() => useLicensing(), { wrapper });

      await waitFor(() => expect(result2.current.plansLoading).toBe(false));

      const secondDataTimestamp = queryClient.getQueryState(licensingKeys.plans())?.dataUpdatedAt;

      // Data should not have been refetched (same timestamp)
      expect(secondDataTimestamp).toBe(firstDataTimestamp);
    });

    it("should deduplicate concurrent entitlement checks", async () => {
      seedSubscription({
        id: "sub-1",
        tenant_id: "tenant-1",
        plan_id: "plan-1",
        status: "ACTIVE",
        billing_cycle: "MONTHLY",
      });

      const queryClient = new QueryClient({
        defaultOptions: { queries: { retry: false }, mutations: { retry: false } },
      });

      const wrapper = ({ children }: { children: React.ReactNode }) => (
        <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
      );

      // Render two entitlement checks for the same module concurrently
      const { result: result1 } = renderHook(
        () => useFeatureEntitlement("BILLING", "CREATE_INVOICE"),
        { wrapper }
      );
      const { result: result2 } = renderHook(
        () => useFeatureEntitlement("BILLING", "CREATE_INVOICE"),
        { wrapper }
      );

      await waitFor(() => {
        expect(result1.current.isLoading).toBe(false);
        expect(result2.current.isLoading).toBe(false);
      });

      // Both should return the same result
      expect(result1.current.data).toEqual(result2.current.data);
    });

    it("should deduplicate concurrent quota checks", async () => {
      seedQuotas([
        {
          id: "quota-1",
          quota_code: "SUBSCRIBERS",
          quota_name: "Subscribers",
          default_limit: 100,
        },
      ]);
      seedQuotaUsage("SUBSCRIBERS", 50);

      const queryClient = new QueryClient({
        defaultOptions: { queries: { retry: false }, mutations: { retry: false } },
      });

      const wrapper = ({ children }: { children: React.ReactNode }) => (
        <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
      );

      // Render two quota checks concurrently
      const { result: result1 } = renderHook(() => useQuotaCheck("SUBSCRIBERS", 10), {
        wrapper,
      });
      const { result: result2 } = renderHook(() => useQuotaCheck("SUBSCRIBERS", 10), {
        wrapper,
      });

      await waitFor(() => {
        expect(result1.current.isLoading).toBe(false);
        expect(result2.current.isLoading).toBe(false);
      });

      // Both should return the same result
      expect(result1.current.data).toEqual(result2.current.data);
      expect(result1.current.data?.available).toBe(true);
    });
  });
});
